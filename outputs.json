{
  "experiments": {
    "1": {
      "title": "Polynomials",
      "output": "=== POLYNOMIAL ADDITION USING ARRAYS ===\n\n--- Example 1 ---\n\nEnter number of terms in first polynomial: 3\nEnter coefficients and exponents for first polynomial:\nTerm 1 coeff and exp: 5 2\nTerm 2 coeff and exp: 4 1\nTerm 3 coeff and exp: 2 0\n\nFirst Polynomial: 5x^2 + 4x^1 + 2x^0\n\nEnter number of terms in second polynomial: 3\nEnter coefficients and exponents for second polynomial:\nTerm 1 coeff and exp: 3 2\nTerm 2 coeff and exp: 2 1\nTerm 3 coeff and exp: 1 0\n\nSecond Polynomial: 3x^2 + 2x^1 + 1x^0\n\nAddition Process:\nComparing exponents:\n  5x^2 + 3x^2 = 8x^2\n  4x^1 + 2x^1 = 6x^1\n  2x^0 + 1x^0 = 3x^0\n\nResultant Polynomial:\n8x^2 + 6x^1 + 3x^0\n\n--- Example 2: Different Exponents ---\n\nFirst Polynomial: 3x^3 + 2x^1\nSecond Polynomial: 4x^2 + 5x^1 + 1x^0\n\nResultant Polynomial:\n3x^3 + 4x^2 + 7x^1 + 1x^0"
    },
    "2": {
      "title": "Sparse Matrix",
      "output": "=== SPARSE MATRIX REPRESENTATION ===\n\nA sparse matrix is a matrix with majority of elements as zero.\nEfficient storage: Store only non-zero elements.\n\n--- Example 1 ---\n\nEnter number of rows and columns: 4 5\nEnter number of non-zero elements: 3\nEnter row, column and value:\n0 1 5\n1 3 8\n3 2 7\n\nOriginal Matrix (4x5):\n0  5  0  0  0\n0  0  0  8  0\n0  0  0  0  0\n0  0  7  0  0\n\nSparse Matrix Representation (3-tuple format):\nRow\tColumn\tValue\n0\t1\t5\n1\t3\t8\n3\t2\t7\n\nSpace Saved:\nOriginal: 4 × 5 = 20 elements\nSparse: 3 non-zero elements\nCompression Ratio: 85%\n\n--- Example 2 ---\n\nOriginal Matrix (5x5):\n0  0  3  0  4\n0  0  5  7  0\n0  0  0  0  0\n0  2  6  0  0\n0  0  0  0  0\n\nSparse Matrix Representation:\nRow\tColumn\tValue\n0\t2\t3\n0\t4\t4\n1\t2\t5\n1\t3\t7\n3\t1\t2\n3\t2\t6\n\nTotal non-zero elements: 6 out of 25"
    },
    "3": {
      "title": "Infix to Postfix",
      "output": "=== INFIX TO POSTFIX CONVERSION ===\n\nOperator Precedence:\n^ (highest)\n* /\n+ - (lowest)\n\n--- Example 1 ---\n\nEnter infix expression: (A+B)*C-D/E\n\nConversion Process:\nSymbol | Stack      | Postfix\n-------|------------|--------\n(      | (          |\nA      | (          | A\n+      | ( +        | A\nB      | ( +        | A B\n)      |            | A B +\n*      | *          | A B +\nC      | *          | A B + C\n-      | -          | A B + C *\nD      | -          | A B + C * D\n/      | - /        | A B + C * D\nE      | - /        | A B + C * D E\nEND    |            | A B + C * D E / -\n\nPostfix expression: AB+C*DE/-\n\n--- Example 2 ---\n\nEnter infix expression: A+B*C\nPostfix expression: ABC*+\n\n--- Example 3 ---\n\nEnter infix expression: (A+B)*(C-D)\nPostfix expression: AB+CD-*\n\n--- Example 4 ---\n\nEnter infix expression: A^B^C\nPostfix expression: ABC^^"
    },
    "4a": {
      "title": "Linear Queue",
      "output": "=== LINEAR QUEUE OPERATIONS ===\n\nMenu Options:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n\n--- Example Execution ---\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 1\nEnter the element to be added: 10\n\nElement has been added successfully!!\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 1\nEnter the element to be added: 20\n\nElement has been added successfully!!\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 1\nEnter the element to be added: 30\n\nElement has been added successfully!!\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 3\nQueue elements: 10\t20\t30\t\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 2\nDeleted element is 10\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 3\nQueue elements: 20\t30\t\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 4"
    },
    "4b": {
      "title": "Double Ended Queue",
      "output": "=== DOUBLE ENDED QUEUE (DEQUE) ===\n\nOperations Available:\n- Insert at Rear\n- Insert at Front\n- Delete from Rear\n- Delete from Front\n- Display\n\n--- Example Execution ---\n\nInserted 10 at rear.\nInserted 20 at rear.\nInserted 5 at front.\nInserted 2 at front.\n\nDeque elements: 2 5 10 20\n\nDeleted 20 from rear.\nDeque elements: 2 5 10\n\nDeleted 2 from front.\nDeque elements: 5 10\n\nInserted 15 at rear.\nInserted 1 at front.\nDeque elements: 1 5 10 15"
    },
    "5": {
      "title": "Circular Queue",
      "output": "=== CIRCULAR QUEUE OPERATIONS ===\n\nMenu Options:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n\n--- Example Execution ---\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 1\nEnter the element to be added: 15\n\nElement has been added successfully!!\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 1\nEnter the element to be added: 25\n\nElement has been added successfully!!\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 1\nEnter the element to be added: 35\n\nElement has been added successfully!!\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 3\nQueue elements: 15\t25\t35\t\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 2\nDeleted element is 15\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 1\nEnter the element to be added: 45\n\nElement has been added successfully!!\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 3\nQueue elements: 25\t35\t45\t\n\nChoose the operations for queue:\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\nOption: 4"
    },
    "6": {
      "title": "Browser Navigation",
      "output": "=== BROWSER NAVIGATION USING STACKS ===\n\nOperations:\n- Visit new page (push to back stack)\n- Go back (pop from back stack, push to forward stack)\n- Go forward (pop from forward stack, push to back stack)\n\n--- Example Execution ---\n\nOperation 1: Visit home.html\nBack Stack: [home.html]\nForward Stack: []\nCurrent Page: home.html\n\nOperation 2: Visit about.html\nBack Stack: [home.html, about.html]\nForward Stack: []\nCurrent Page: about.html\n\nOperation 3: Visit contact.html\nBack Stack: [home.html, about.html, contact.html]\nForward Stack: []\nCurrent Page: contact.html\n\nOperation 4: Visit services.html\nBack Stack: [home.html, about.html, contact.html, services.html]\nForward Stack: []\nCurrent Page: services.html\n\nOperation 5: Go Back\nBack Stack: [home.html, about.html, contact.html]\nForward Stack: [services.html]\nCurrent Page: contact.html\n\nOperation 6: Go Back\nBack Stack: [home.html, about.html]\nForward Stack: [services.html, contact.html]\nCurrent Page: about.html\n\nOperation 7: Go Forward\nBack Stack: [home.html, about.html, contact.html]\nForward Stack: [services.html]\nCurrent Page: contact.html\n\nOperation 8: Visit portfolio.html\nBack Stack: [home.html, about.html, contact.html, portfolio.html]\nForward Stack: [] (cleared on new visit)\nCurrent Page: portfolio.html\n\nBrowsing History:\nhome.html -> about.html -> contact.html -> portfolio.html"
    },
    "7": {
      "title": "Polynomials using Linked List",
      "output": "=== POLYNOMIAL ADDITION USING LINKED LISTS ===\n\n--- Example 1 ---\n\nEnter number of terms in polynomial 1: 3\nEnter coefficient and exponent:\n5 2\n4 1\n2 0\n\nPolynomial 1 (Linked List):\n[5,2] -> [4,1] -> [2,0] -> NULL\nRepresentation: 5x^2 + 4x^1 + 2x^0\n\nEnter number of terms in polynomial 2: 2\nEnter coefficient and exponent:\n3 2\n1 0\n\nPolynomial 2 (Linked List):\n[3,2] -> [1,0] -> NULL\nRepresentation: 3x^2 + 1x^0\n\nAddition Process:\nNode 1: exp(2) == exp(2) → 5+3 = 8x^2\nNode 2: exp(1) only in P1 → 4x^1\nNode 3: exp(0) == exp(0) → 2+1 = 3x^0\n\nResultant Polynomial (Linked List):\n[8,2] -> [4,1] -> [3,0] -> NULL\n\nResultant Polynomial: 8x^2 + 4x^1 + 3x^0\n\n--- Example 2 ---\n\nPolynomial 1: 6x^4 + 3x^2 + 2x^0\nPolynomial 2: 4x^3 + 2x^2 + 5x^1\n\nResultant Polynomial: 6x^4 + 4x^3 + 5x^2 + 5x^1 + 2x^0"
    },
    "8": {
      "title": "Binary Tree",
      "output": "=== BINARY TREE TRAVERSALS ===\n\nTree Structure:\n        1\n       / \\\n      2   3\n     / \\ / \\\n    4  5 6  7\n\nTraversal Methods:\n1. Inorder (Left-Root-Right)\n2. Preorder (Root-Left-Right)\n3. Postorder (Left-Right-Root)\n\n--- Traversal Results ---\n\nInorder Traversal:\n4 2 5 1 6 3 7\n\nPreorder Traversal:\n1 2 4 5 3 6 7\n\nPostorder Traversal:\n4 5 2 6 7 3 1\n\n--- Another Example ---\n\nTree Structure:\n      10\n     /  \\\n    5    15\n   / \\     \\\n  3   7    20\n\nInorder: 3 5 7 10 15 20\nPreorder: 10 5 3 7 15 20\nPostorder: 3 7 5 20 15 10"
    },
    "9": {
      "title": "Binary Search Tree",
      "output": "=== EXPRESSION TREE FROM INFIX ===\n\nTest Case 1:\nEnter infix expression: (A+B)*C\nPostfix expression: AB+C*\nPreorder traversal: * + A B C\n\n--- Test Case 2 ---\nEnter infix expression: A+B*C-D/E\nPostfix expression: ABC*+DE/-\nPreorder traversal: - + A * B C / D E\n\n--- Test Case 3 ---\nEnter infix expression: (A+B)*(C-D)\nPostfix expression: AB+CD-*\nPreorder traversal: * + A B - C D"
    },
    "10": {
      "title": "Breadth First Search",
      "output": "=== BREADTH FIRST SEARCH (BFS) ===\n\nGraph Representation: Adjacency Matrix\n\n--- Example 1 ---\n\nEnter number of vertices: 5\nEnter adjacency matrix:\n  0 1 2 3 4\n0 0 1 1 0 0\n1 1 0 0 1 1\n2 1 0 0 1 0\n3 0 1 1 0 1\n4 0 1 0 1 0\n\nGraph Structure:\n    0\n   / \\\n  1   2\n / \\   \\\n3   4   3\n \\     /\n  4---\n\nBFS Traversal starting from vertex 0:\nQueue: [0]\nVisited: 0\nQueue: [1, 2]\nVisited: 0 1\nQueue: [2, 3, 4]\nVisited: 0 1 2\nQueue: [3, 4]\nVisited: 0 1 2 3\nQueue: [4]\nVisited: 0 1 2 3 4\n\nFinal BFS Order: 0 1 2 3 4\n\n--- Example 2 ---\n\nEnter number of vertices: 4\nEnter adjacency matrix:\n  0 1 2 3\n0 0 1 1 1\n1 1 0 0 0\n2 1 0 0 1\n3 1 0 1 0\n\nBFS Traversal starting from vertex 0:\n0 1 2 3"
    },
    "11": {
      "title": "Depth First Search",
      "output": "No code available for this experiment"
    },
    "12": {
      "title": "Binary Search",
      "output": "=== BINARY SEARCH ALGORITHM ===\n\nRequirement: Array must be sorted\nTime Complexity: O(log n)\n\n--- Test Case 1: Element Found ---\n\nEnter number of elements: 7\nEnter sorted array: 10 20 30 40 50 60 70\nEnter element to search: 40\n\nSearch Process:\nIteration 1: low=0, high=6, mid=3\n  Array[3] = 40\n  Element found!\n\nElement 40 found at index 3\n\n--- Test Case 2: Element Not Found ---\n\nEnter number of elements: 7\nEnter sorted array: 10 20 30 40 50 60 70\nEnter element to search: 35\n\nSearch Process:\nIteration 1: low=0, high=6, mid=3\n  Array[3] = 40 > 35, search left half\nIteration 2: low=0, high=2, mid=1\n  Array[1] = 20 < 35, search right half\nIteration 3: low=2, high=2, mid=2\n  Array[2] = 30 < 35, search right half\nIteration 4: low=3, high=2\n  low > high, element not found\n\nElement 35 not found in array\n\n--- Test Case 3: First Element ---\n\nEnter number of elements: 5\nEnter sorted array: 5 15 25 35 45\nEnter element to search: 5\n\nElement 5 found at index 0\n\n--- Test Case 4: Last Element ---\n\nEnter number of elements: 5\nEnter sorted array: 5 15 25 35 45\nEnter element to search: 45\n\nElement 45 found at index 4"
    },
    "13a": {
      "title": "Bubble Sort",
      "output": "=== BUBBLE SORT ALGORITHM ===\n\nTest Case 1:\nEnter number of elements: 5\nEnter elements: 64 34 25 12 22\n\nOriginal array: 64 34 25 12 22\n\nPass 1: 34 25 12 22 64\nPass 2: 25 12 22 34 64\nPass 3: 12 22 25 34 64\nPass 4: 12 22 25 34 64\n\nSorted array: 12 22 25 34 64\n\nNumber of comparisons: 10\nNumber of swaps: 8\n\n--- Test Case 2 (Already Sorted) ---\nEnter number of elements: 4\nEnter elements: 10 20 30 40\n\nOriginal array: 10 20 30 40\nSorted array: 10 20 30 40\n\nNumber of comparisons: 6\nNumber of swaps: 0\n\n--- Test Case 3 (Reverse Sorted) ---\nEnter number of elements: 4\nEnter elements: 40 30 20 10\n\nOriginal array: 40 30 20 10\nSorted array: 10 20 30 40\n\nNumber of comparisons: 6\nNumber of swaps: 6"
    },
    "13b": {
      "title": "Insertion Sort",
      "output": "=== INSERTION SORT ALGORITHM ===\n\nTest Case 1:\nEnter number of elements: 5\nEnter elements: 64 34 25 12 22\n\nOriginal array: 64 34 25 12 22\n\nStep 1: 34 64 25 12 22\nStep 2: 25 34 64 12 22\nStep 3: 12 25 34 64 22\nStep 4: 12 22 25 34 64\n\nSorted array: 12 22 25 34 64\n\nNumber of comparisons: 10\n\n--- Test Case 2 (Small Array) ---\nEnter number of elements: 3\nEnter elements: 5 2 8\n\nOriginal array: 5 2 8\nSorted array: 2 5 8\n\nNumber of comparisons: 3"
    },
    "13c": {
      "title": "Quick Sort",
      "output": "=== QUICK SORT ALGORITHM ===\n\nTest Case 1:\nEnter number of elements: 6\nEnter elements: 38 27 43 3 9 82\n\nOriginal array: 38 27 43 3 9 82\n\nPartitioning with pivot 38:\n  Left: 27 3 9\n  Pivot: 38\n  Right: 43 82\n\nPartitioning with pivot 27:\n  Left: 3 9\n  Pivot: 27\n\nPartitioning with pivot 43:\n  Pivot: 43\n  Right: 82\n\nSorted array: 3 9 27 38 43 82\n\nQuick Sort completed successfully\n\n--- Test Case 2 ---\nEnter number of elements: 5\nEnter elements: 10 7 8 9 1\n\nOriginal array: 10 7 8 9 1\nSorted array: 1 7 8 9 10"
    },
    "13d": {
      "title": "Merge Sort",
      "output": "=== MERGE SORT ALGORITHM ===\n\nTest Case 1:\nEnter number of elements: 6\nEnter elements: 38 27 43 3 9 82\n\nOriginal array: 38 27 43 3 9 82\n\nDividing:\n  [38 27 43] [3 9 82]\n  [38] [27 43] [3] [9 82]\n  [38] [27] [43] [3] [9] [82]\n\nMerging:\n  [27 38 43] [3 9 82]\n  [3 9 27 38 43 82]\n\nSorted array: 3 9 27 38 43 82\n\nMerge Sort completed successfully\n\n--- Test Case 2 ---\nEnter number of elements: 4\nEnter elements: 12 11 13 5\n\nOriginal array: 12 11 13 5\nSorted array: 5 11 12 13"
    },
    "14": {
      "title": "Memory Allocation",
      "output": "=== MEMORY ALLOCATION STRATEGIES ===\n\nMenu Options:\n1. Allocate Process\n2. Free Process\n3. Exit\n\nAllocation Methods:\n1. First Fit - Allocate first block that fits\n2. Best Fit - Allocate smallest block that fits\n3. Worst Fit - Allocate largest block that fits\n\n--- Example Execution ---\n\nEnter number of memory blocks: 5\nEnter size of block 1: 100\nEnter size of block 2: 500\nEnter size of block 3: 200\nEnter size of block 4: 300\nEnter size of block 5: 600\n\nMemory Blocks:\n[ Free | Size: 100 ] <-> [ Free | Size: 500 ] <-> [ Free | Size: 200 ] <-> [ Free | Size: 300 ] <-> [ Free | Size: 600 ] <-> NULL\n\nMenu:\n1. Allocate Process\t 2. Free Process\t 3. Exit\nEnter choice: 1\nEnter process size: 212\nChoose allocation method: 1.First Fit 2.Best Fit 3.Worst Fit : 1\nProcess 1 allocated 212 units\n\nMemory Blocks:\n[ Free | Size: 100 ] <-> [ P1 | Size: 212 ] <-> [ Free | Size: 288 ] <-> [ Free | Size: 200 ] <-> [ Free | Size: 300 ] <-> [ Free | Size: 600 ] <-> NULL\n\nMenu:\n1. Allocate Process\t 2. Free Process\t 3. Exit\nEnter choice: 1\nEnter process size: 417\nChoose allocation method: 1.First Fit 2.Best Fit 3.Worst Fit : 2\nProcess 2 allocated 417 units\n\nMemory Blocks:\n[ Free | Size: 100 ] <-> [ P1 | Size: 212 ] <-> [ Free | Size: 288 ] <-> [ Free | Size: 200 ] <-> [ Free | Size: 300 ] <-> [ P2 | Size: 417 ] <-> [ Free | Size: 183 ] <-> NULL\n\nMenu:\n1. Allocate Process\t 2. Free Process\t 3. Exit\nEnter choice: 1\nEnter process size: 112\nChoose allocation method: 1.First Fit 2.Best Fit 3.Worst Fit : 3\nProcess 3 allocated 112 units\n\nMemory Blocks:\n[ Free | Size: 100 ] <-> [ P1 | Size: 212 ] <-> [ P3 | Size: 112 ] <-> [ Free | Size: 176 ] <-> [ Free | Size: 200 ] <-> [ Free | Size: 300 ] <-> [ P2 | Size: 417 ] <-> [ Free | Size: 183 ] <-> NULL\n\nMenu:\n1. Allocate Process\t 2. Free Process\t 3. Exit\nEnter choice: 2\nEnter process ID to free: 1\nProcess 1 freed\n\nMemory Blocks:\n[ Free | Size: 100 ] <-> [ Free | Size: 212 ] <-> [ P3 | Size: 112 ] <-> [ Free | Size: 176 ] <-> [ Free | Size: 200 ] <-> [ Free | Size: 300 ] <-> [ P2 | Size: 417 ] <-> [ Free | Size: 183 ] <-> NULL\n\nAfter Garbage Collection:\n[ Free | Size: 312 ] <-> [ P3 | Size: 112 ] <-> [ Free | Size: 676 ] <-> [ P2 | Size: 417 ] <-> [ Free | Size: 183 ] <-> NULL\n\nMenu:\n1. Allocate Process\t 2. Free Process\t 3. Exit\nEnter choice: 3"
    },
    "15": {
      "title": "Garbage Collector",
      "output": "=== GARBAGE COLLECTION SIMULATION ===\n\nGarbage Collection: Automatic memory management\nCoalescing: Merging adjacent free blocks\n\n--- Example Execution ---\n\nInitial Memory: 1000 KB\nMemory Blocks:\n[ Free | Size: 1000 ] <-> NULL\n\nOperation 1: Allocate 200 KB (Object 1)\nMemory Blocks:\n[ Object 1 | Size: 200 ] <-> [ Free | Size: 800 ] <-> NULL\nFree Memory: 800 KB\n\nOperation 2: Allocate 300 KB (Object 2)\nMemory Blocks:\n[ Object 1 | Size: 200 ] <-> [ Object 2 | Size: 300 ] <-> [ Free | Size: 500 ] <-> NULL\nFree Memory: 500 KB\n\nOperation 3: Allocate 150 KB (Object 3)\nMemory Blocks:\n[ Object 1 | Size: 200 ] <-> [ Object 2 | Size: 300 ] <-> [ Object 3 | Size: 150 ] <-> [ Free | Size: 350 ] <-> NULL\nFree Memory: 350 KB\n\nOperation 4: Free Object 2\nMemory Blocks:\n[ Object 1 | Size: 200 ] <-> [ Free | Size: 300 ] <-> [ Object 3 | Size: 150 ] <-> [ Free | Size: 350 ] <-> NULL\nFree Memory: 650 KB (fragmented)\n\nOperation 5: Garbage Collection (Coalescing)\nScanning for adjacent free blocks...\nNo adjacent free blocks found.\n\nOperation 6: Free Object 3\nMemory Blocks:\n[ Object 1 | Size: 200 ] <-> [ Free | Size: 300 ] <-> [ Free | Size: 150 ] <-> [ Free | Size: 350 ] <-> NULL\n\nOperation 7: Garbage Collection (Coalescing)\nCoalescing adjacent free blocks...\nMerged: 300 + 150 + 350 = 800 KB\n\nMemory Blocks After GC:\n[ Object 1 | Size: 200 ] <-> [ Free | Size: 800 ] <-> NULL\nFree Memory: 800 KB (defragmented)\n\nGarbage Collection Summary:\n- Freed fragmented memory\n- Coalesced 3 blocks into 1 large block\n- Improved memory allocation efficiency"
    },
    "16": {
      "title": "Hash Table",
      "output": "=== HASH TABLE IMPLEMENTATION ===\n\nHash Function: key % table_size\nCollision Resolution: Chaining (Linked List)\n\n--- Example Execution ---\n\nHash Table Size: 10\n\nOperation 1: Insert (5, 'Apple')\nHash(5) = 5\nInserted at index 5\n\nOperation 2: Insert (15, 'Banana')\nHash(15) = 5\nCollision at index 5! Adding to chain.\n\nOperation 3: Insert (25, 'Cherry')\nHash(25) = 5\nCollision at index 5! Adding to chain.\n\nOperation 4: Insert (35, 'Date')\nHash(35) = 5\nCollision at index 5! Adding to chain.\n\nOperation 5: Insert (12, 'Elderberry')\nHash(12) = 2\nInserted at index 2\n\nHash Table Contents:\nIndex 0: NULL\nIndex 1: NULL\nIndex 2: 12->NULL\nIndex 3: NULL\nIndex 4: NULL\nIndex 5: 5->15->25->35->NULL\nIndex 6: NULL\nIndex 7: NULL\nIndex 8: NULL\nIndex 9: NULL\n\nOperation 6: Search key 15\nHash(15) = 5\nSearching in chain at index 5...\nFound: 'Banana'\n\nOperation 7: Search key 20\nHash(20) = 0\nNot Found\n\nOperation 8: Delete key 25\nHash(25) = 5\nDeleted 'Cherry' from index 5\n\nHash Table after deletion:\nIndex 0: NULL\nIndex 1: NULL\nIndex 2: 12->NULL\nIndex 3: NULL\nIndex 4: NULL\nIndex 5: 5->15->35->NULL\nIndex 6: NULL\nIndex 7: NULL\nIndex 8: NULL\nIndex 9: NULL\n\nLoad Factor: 4/10 = 0.4"
    }
  }
}

